# 지네릭스, 열거형, 에너테이션

## 지네릭스(Generics)

지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크(compile-time type check)를 해주는 기능이다. 객체의 타입을 컴파일 시에 채크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다.
예를 들어 ArrayList의 경우 다양한 종류의 객체를 담을 수 있긴 하지만 보통 한 종류의 객체를 담는 경우가 많다. 아래와 같이 ArrayList를 생성할 때, 저장할 객체의 타입을 지정해 주면, 지정한 타입 외에 다른 타입의 객체가 저장되면 에러가 발생한다.

그리고 저장된 객체를 꺼낼 때는 형변환할 필요가 없어서 편리하다. 이미 어떤 타입의 객체들이 저장되어 있는지 알고 있기 때문이다.

```java
ArrayList<Tv> tvList = new ArrayList<Tv>();

tvList.add(new Tv());
Tv t = tvlist.get(0); // 형변환 불필요
```

- **지네릭스의 장점**
  1. 타입 안정성을 제공한다.
  2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해 진다.

---

## 타입 변수

ArrayList클래스의 선언에서 클래스 이름 옆의 '<>'안에 있는 E를 타입 변수(type variable)'라고 하며, 일반적으로는 'Type'의 첫 글자를 따서 T를 사용한다.

그렇다고 타입 변수로 반드시 T를 사용해야 하는 것은 아니며, T가 아닌 다른 것을 사용해도 된다. ArrayList<E>의 경우, 'Element(요소)'의 첫 글자를 따서 타입 변수의 이름으로 E를 사용한다.

```java
public class ArrayList<E> extends AbstractList<E> { // 일부 생략
    private transient E[] elementData;
    public boolean add(E o) { // }
    public E get(int index) { // }
        ...
}
```

기존에는 다양한 종류의 타입을 다루는 메서드의 매개변수나 리턴타입으로 Object타입의 참조변수를 많이 사용했고, 그로 인해 형변환이 불가피했지만, 이젠 Object타입 대신 원하는 타입을 지정하기만 하면 되는 것이다.

---

## 타입 변수에 대입하기

```java
// 타입 변수 E 대신에 실제 타입 Tv를 대입
ArrayList<Tv> tvList = new ArrayList<Tv>();
```

이때, 타입 변수 E대신 지정된 타입 Tv를 '대입된 타입(parameterized type)'이라고 한다.

```java
public class ArrayList extends AbstractList<E> { // 일부 생략
    private transient Tv[] elementData;
    public boolean add(Tv o) { // }
    public Tv get(int index) { // } // Object가 아닌 Tv를 반환
        ...
}
```

---

## 지네릭스의 용어

```java
class Box<T> {}
```

- **Box(T)** 지네릭 클래스. 'T의 Box' 또는 'T Box' 라고 읽는다.
- **T** 타입 변수 또는 타입 매개변수.(T는 타입 문자)
- **Box** 원시 타입(raw type)

---

## 지네릭 타입과 다형성

```java
ArrayList<Product> list = new ArrayList<Product>();
list.add(new Product());
list.add(new Tv()); //OK.
list.add(new Audio()); // OK.
```

대신 ArrayList에 저장된 객체를 꺼낼 때, 형변환이 필요하다.

```java
Product p = list.get(0); // Product객체는 형변환이 필요없다.
Tv t = (Tv)list.get(1); // Product의 자손객체들은 형변환을 필요로 한다.
```

```java
import java.util.*;

class Product {}
class Tv extends Product {}
class Audio extends Product {}

class Ex12_1 {
	public static void main(String[] args) {
		ArrayList<Product> productList = new ArrayList<Product>();
		ArrayList<Tv>      tvList = new ArrayList<Tv>();
//  	ArrayList<Product> tvList = new ArrayList<Tv>(); // 에러.
// 		List<Tv>           tvList = new ArrayList<Tv>(); // OK. 다형성

		productList.add(new Tv());
		productList.add(new Audio());

		tvList.add(new Tv());
		tvList.add(new Tv());

		printAll(productList);
		// printAll(tvList); // 컴파일 에러가 발생한다.
	}

	public static void printAll(ArrayList<Product> list) {
		for (Product p : list)
			System.out.println(p);
	}
}

// Tv@15db9742
// Audio@6d06d69c
```

---