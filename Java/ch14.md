# 람다와 스트림

## 람다식(Lambda Expression)

람다식(Lambda expression)은 간단히 말해서 메서드를 하나의 '식(expression)'으로 표현한 것이다. 람다식은 함수를 간략하면서도 명확하게 표현할 수 있게 해준다.

메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 '익명 함수(anonymous function)'라고도 한다.

---

## 람다식 작성하기

메서드를 람다식으로 만드는 방법은 아주 간단하다. 메서드에서 이름과 반환타입을 제거하고 매개변수 선언부와 몸통{} 사이에 '->'를 추가하기만 하면 된다.

```java
int max(int a, int b) {
    return a > b ? a : b;
}

    ->

(int a, int b) -> {
    return a > b ? a : b;
}
```

반환값이 있는 메서드의 경우, return문 대신 '식(expression)'으로 대신 할 수 있다. 식의 연산결과가 자동적으로 반환값이 된다. 이때는 '문장(statement)'이 아닌 '식'이므로 끝에 ';'을 붙이지 않는다.

```java
(int a, int b) -> {return a > b ? a : b; }

    ->

(int a, int b) -> a > b ? a : b
```

람다식에 선언된 매개변수의 타입은 추론이 가능한 경우는 생략할 수 있는데, 대부분의 경우에 생략가능하다. 람다식에 반환타입이 없는 이유도 항상 추론이 가능하기 때문이다.

```java
(int a, int b) -> a > b ? a : b

    ->

(a, b) -> a > b ? a : b
```

---

## 람다식은 익명 함수? 익명 객체!

자바에서 모든 메서드는 클래스 내에 포함되어야 하는데, 람다식은 어떤 클래스에 포함되는 것일까? 지금까지 람다식이 메서드와 동등한 것처럼 설명해왔지만, 사실 람다식은 익명 클래스의 객체와 동등하다.

```java
(int a, int b) -> a > b ? a : b

    ->

new Object() {
    int max(int a, int b) {
        return a > b ? a : b;
    }
}
```

---

## 함수형 인터페이스(Functional Interface)

예를 들어 아래와 같이 메서드 max가 선언된 MyFunction인터페이스가 정의되어 있다고 가정하자.

```java
interface MyFunction {
    public abstract int max(int a, int b);
}
```

그러면 이 인터페이스를 구현한 익명 클래스의 객체는 다음과 같이 생성할 수 있다.

```java
MyFunction f = new MyFunction() {
    public int max(int a, int b) {
        return a > b ? a : b;
    }
};

int big = f.max(5, 3); // 익명 객체의 메서드를 호출
```

MyFunction인터페이스에 정의된 메서드 max()는 람다식 '(int a, int b) -> a > b ? a : b'과 일치한다.

```java
MyFunction f = (int a, int b) -> a > b ? a : b; // 익명 객체를 람다식으로 대체
int big = f.max(5, 3); // 익명 객체의 메서드를 호출
```

이처럼 MyFunction인터페이스를 구현한 익명 객체를 람다식으로 대체가 가능한 이유는, 람다식도 실제로는 익명 객체이고, MyFunction인터페이스를 구현한 익명 객체의 메서드 max()와 람다식의 매개변수의 타입과 개수 그리고 반환값이 일치하기 때문이다.

```java
@FunctionalInterface
interface MyFunction {
    public abstract int max(int a, int b);
}
```

---

## 함수혐 인터페이스 타입의 매개변수, 반환 타입

함수형 인터페이스 MyFunction이 아래와 같이 정의되어 있을 때,

```java
@FunctionalInterface
interface MyFunction {
    void myMethod(); // 추상 메서드
}
```

메서드의 매개변수가 MyFunction타입이면, 이 메서드를 호출할 때 람다식을 참조하는 참조변수를 매개변수로 지정해야한다는 뜻이다.

```java
void aMethod(MyFuncition f) { // 매개변수의 타입이 함수형 인터페이스
    f.myMethod(); // MyFunction에 정의된 메서드 호출
}
    ...
MyFunction f = () -> System.out.println("myMethod()");
aMethod(f);
```

또는 참조변수 없이 아래와 같이 직접 람다식을 매개변수로 지정하는 것도 가능하다.

```java
aMethod(() -> System.out.println("myMethod()")); // 람다식을 매개변수로 지정
```

그리고 메서드의 반환타입이 함수형 인터페이스타입이라면, 이 함수형 인터페이스의 추상메서드와 동등한 람다식을 가리키는 참조변수를 반환하거나 람다식을 직접 반환할 수 있다.

```java
MyFunction meMethod() {
    MyFunction f = () -> {};
    return f; // 이 줄과 윗 줄을 한줄로 줄이면, return () -> {};
}
```

람다식을 참조변수로 다룰 수 있다는 것은 메서드를 통해 람다식을 주고받을 수 있다는 것을 의마한다. 즉, 변수처럼 메서드를 주고받는 것이 가능해진 것이다.

```java
@FunctionalInterface
interface MyFunction {
	void run();  // public abstract void run();
}

class Ex14_1 {
	static void execute(MyFunction f) { // 매개변수의 타입이 MyFunction인 메서드
		f.run();
	}

	static MyFunction getMyFunction() { // 반환 타입이 MyFunction인 메서드 
		MyFunction f = () -> System.out.println("f3.run()");
		return f;
	}

	public static void main(String[] args) {
		// 람다식으로 MyFunction의 run()을 구현
		MyFunction f1 = ()-> System.out.println("f1.run()");

		MyFunction f2 = new MyFunction() {  // 익명클래스로 run()을 구현
			public void run() {   // public을 반드시 붙여야 함
				System.out.println("f2.run()");
			}
		};

		MyFunction f3 = getMyFunction();

		f1.run();
		f2.run();
		f3.run();

		execute(f1);
		execute( ()-> System.out.println("run()") );
	}
}

// f1.run()
// f2.run()
// f3.run()
// f1.run()
// run()
```

---

## java.util.function패키지

java.util.function패키지에 일반적으로 자주 쓰이는 형식의 메서드를 함수형 인터페이스로 미리 정의해 놓았다.

|함수형 인터페이스|메서드|설명|
|:---:|:---:|:---|
|java.lang.Runnable|void **run**()|매개변수도 없고, 반환값도 없음.|
|Supplier<T>|T **get**() -> T|매개변수는 없고, 반환값만 있음.|
|Consumer<T>|T -> void **accept**(T t)|Supplier와 반대로 매개변수만 있고, 반환값이 없음|
|Function<T, R>|T -> R **apply**(T t) -> R|일반적인 함수. 하나의 매개변수를 받아서 결과를 반환|
|Predicate<T>|T -> boolean **test**(T t) -> boolean|조건식을 표현하는데 사용됨. <br>매개변수는 하나, 반환타입은 boolean|

```java
import java.util.function.*;
import java.util.*;

class Ex14_2 {
	public static void main(String[] args) {
		Supplier<Integer>  s = ()-> (int)(Math.random()*100)+1;
		Consumer<Integer>  c = i -> System.out.print(i+", "); 
		Predicate<Integer> p = i -> i%2==0; 
		Function<Integer, Integer> f = i -> i/10*10; // i의 일의 자리를 없앤다.
		
		List<Integer> list = new ArrayList<>();	
		makeRandomList(s, list);
		System.out.println(list);
		printEvenNum(p, c, list);
		List<Integer> newList = doSomething(f, list);
		System.out.println(newList);
	}

	static <T> List<T> doSomething(Function<T, T> f, List<T> list) {
		List<T> newList = new ArrayList<T>(list.size());

		for(T i : list) {
			newList.add(f.apply(i));
		}	

		return newList;
	}

	static <T> void printEvenNum(Predicate<T> p, Consumer<T> c, List<T> list) {
		System.out.print("[");
		for(T i : list) {
			if(p.test(i))
				c.accept(i);
		}	
		System.out.println("]");
	}

	static <T> void makeRandomList(Supplier<T> s, List<T> list) {
		for(int i=0;i<10;i++) {
			list.add(s.get());
		}
	}
}

// [52, 57, 47, 42, 100, 5, 77, 70, 91, 37]
// [52, 42, 100, 70, ]
// [50, 50, 40, 40, 100, 0, 70, 70, 90, 30]
```